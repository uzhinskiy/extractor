func apiIndex(w http.ResponseWriter, r *http.Request) {
	var fromClient apiRequest
	var remoteIP string
	var whoami string
	var requestUUID string

	sdl.RLock()
	defer sdl.RUnlock()

	defer r.Body.Close()

	fmt.Println("Max AJO v. is: ", ajoVersion)

	// Получаем оригинальный IP клиента
	remoteIP = getIP(r.RemoteAddr, r.Header.Get("X-Real-IP"), r.Header.Get("X-Forwarded-For"))
	// Устанавливаем время запроса
	requestTime := time.Now().Format(time.RFC3339Nano)

	w.Header().Add("Access-Control-Allow-Origin", "*")
	w.Header().Add("Access-Control-Allow-Methods", "POST,OPTIONS") //!!!
	w.Header().Add("Access-Control-Allow-Credentials", "true")
	w.Header().Add("Access-Control-Allow-Headers", "Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization")
	w.Header().Add("Content-Type", "application/json; charset=utf-8")
	w.Header().Add("Server", appConfig["version"]+" b."+vBuild)

	if r.Method == "OPTIONS" {
		return
	}

	if r.Method != http.MethodPost {
		http.Error(w, "Service Unavailable", http.StatusServiceUnavailable)
		log.Println(remoteIP, "\t", r.Method, "\t", r.URL.Path, "\t", http.StatusServiceUnavailable, "\t", "Invalid request method ", "\t", r.UserAgent())
		return
	}
	err := json.NewDecoder(r.Body).Decode(&fromClient)
	if err != nil {
		http.Error(w, err.Error(), 500)
		log.Println(remoteIP, "\t", r.Method, "\t", r.URL.Path, "\t", 500, "\t", err.Error(), "\t", r.UserAgent())
		return
	}
	// Формируем уникальный ID запроса
	if fromClient.Ruuid != "" {
		requestUUID = fromClient.Ruuid
	} else {
		requestUUID = randString(48)
	}

	currentAjoVersion, ok := fromClient.Meta["ajo_version"].(float64)
	fmt.Printf("ok? %b %s\n", ok, currentAjoVersion)
	if ok {
		fmt.Println("Current AJO v. is: ", currentAjoVersion)
		if currentAjoVersion > ajoVersion {
			// TODO: синхронизация между инстансами приложения
			ajoVersion = currentAjoVersion
		} else {
			if (ajoVersion - currentAjoVersion) > 10 {
				resp := RESPONSE_JSON{
					Action:       fromClient.Action,
					Requestdate:  requestTime,
					Responsedate: time.Now().Format(time.RFC3339Nano),
					Count:        intPtr(-1),
					Status:       intPtr(600),
					Message:      "This app's version is unsupported",
					Result:       nil,
				}

				x := loggerMSG{
					Requestdate:  requestTime,
					Responsedate: time.Now().Format(time.RFC3339Nano),
					Message:      "This app's version is unsupported",
					Remoteip:     remoteIP,
					Action:       fromClient.Action,
					Src:          fromClient.Fields,
					Status:       intPtr(600),
					Useragent:    r.UserAgent(),
					Ruuid:        requestUUID,
				}

				x.Meta = fromClient.Meta

				loggerChan <- x

				j, _ := json.Marshal(resp)
				log.Println(remoteIP, "\t", r.Method, "\t", r.URL.Path, "\t", 600, "\t", "This app's version is unsupported", "\t", r.UserAgent())
				fmt.Fprint(w, fmt.Sprintf("%s", j))
				return
			}

		}
	}

	serviceID := filterServices(sdl, fromClient.Action)

	if serviceID != "" {
		if sdl.sdl[serviceID].Status == "alive" {

			err = fromClient.validateRequest(sdl.sdl[serviceID], fromClient.Action)

			if err != nil {
				resp := RESPONSE_JSON{
					Action:       fromClient.Action,
					Requestdate:  requestTime,
					Responsedate: time.Now().Format(time.RFC3339Nano),
					Count:        intPtr(-1),
					Status:       intPtr(418),
					Message:      "Request '" + fromClient.Action + "' is failed: " + err.Error(),
					Result:       nil,
				}

				x := loggerMSG{
					Requestdate:  requestTime,
					Responsedate: time.Now().Format(time.RFC3339Nano),
					Message:      "Request '" + fromClient.Action + "' is failed: " + err.Error(),
					Remoteip:     remoteIP,
					Action:       fromClient.Action,
					Src:          fromClient.Fields,
					Status:       intPtr(418),
					Useragent:    r.UserAgent(),
					Ruuid:        requestUUID,
				}

				x.Meta = fromClient.Meta

				loggerChan <- x

				j, _ := json.Marshal(resp)
				log.Println("Request '" + fromClient.Action + "' is failed with: " + err.Error())
				fmt.Fprint(w, fmt.Sprintf("%s", j))
				return
			}

			if hasSecureCheck(sdl, fromClient.Action) == true {

				verifyReq := apiRequest{
					Authtoken:  fromClient.Authtoken,
					Ruuid:      requestUUID,
					Action:     "verify_token",
					Routerip:   localip,
					Routerhost: hostname,
				}

				verifyResponse, err := crossRequest(fmt.Sprintf("%s/%s", sdl.sdl["AAA"].Dest, "verify_token"), verifyReq)
				if err != nil {
					resp := RESPONSE_JSON{
						Action:       fromClient.Action,
						Requestdate:  requestTime,
						Responsedate: time.Now().Format(time.RFC3339Nano),
						Count:        intPtr(-1),
						Status:       intPtr(500),
						Message:      "Request '" + fromClient.Action + "' is failed: " + err.Error(),
						Result:       nil,
					}

					x := loggerMSG{
						Requestdate:  requestTime,
						Responsedate: time.Now().Format(time.RFC3339Nano),
						Message:      "Request '" + fromClient.Action + "' is failed: " + err.Error(),
						Remoteip:     remoteIP,
						Action:       fromClient.Action,
						Src:          fromClient.Fields,
						Status:       intPtr(500),
						Useragent:    r.UserAgent(),
						Ruuid:        requestUUID,
					}

					x.Meta = fromClient.Meta

					loggerChan <- x

					j, _ := json.Marshal(resp)
					log.Println("Request '" + fromClient.Action + "' is failed: " + err.Error())
					fmt.Fprint(w, fmt.Sprintf("%s", j))
					return
				}
				if *verifyResponse.Status != 200 {
					resp := RESPONSE_JSON{
						Action:       fromClient.Action,
						Requestdate:  requestTime,
						Responsedate: time.Now().Format(time.RFC3339Nano),
						Count:        intPtr(-1),
						Status:       verifyResponse.Status,
						Message:      "Internal server error: Token is invalid",
						Result:       nil,
					}
					j, _ := json.Marshal(resp)

					x := loggerMSG{
						Requestdate:  requestTime,
						Responsedate: time.Now().Format(time.RFC3339Nano),
						Message:      "Request '" + fromClient.Action + "' is failed: Token is invalid",
						Remoteip:     remoteIP,
						Action:       fromClient.Action,
						Src:          fromClient.Fields,
						Status:       verifyResponse.Status,
						Useragent:    r.UserAgent(),
						Ruuid:        requestUUID,
					}

					x.Meta = fromClient.Meta
					loggerChan <- x

					log.Println(fromClient.Action, " to ", serviceID, " returns: ", "Token is invalid")
					fmt.Fprint(w, fmt.Sprintf("%s", j))
					return
				}

				/*x := loggerMSG{
					Requestdate:  requestTime,
					Responsedate: time.Now().Format(time.RFC3339Nano),
					Message:      "Request '" + fromClient.Action + "' is successful: Token is valid",
					Remoteip:     remoteIP,
					Action:       fromClient.Action,
					Src:          fromClient.Fields,
					Status:       verifyResponse.Status,
					Useragent:    r.UserAgent(),
					Ruuid:        requestUUID,
				}
				x.Meta = fromClient.Meta
				loggerChan <- x*/

				whoami = verifyResponse.Whoami

			} // hasSecureCheck

			fromClient.Ruuid = requestUUID
			fromClient.Routerip = localip
			fromClient.Routerhost = hostname
			fromClient.Whoami = whoami

			// send action to backend
			serviceResponse, err := crossRequest(fmt.Sprintf("%s/%s", sdl.sdl[serviceID].Dest, fromClient.Action), fromClient)

			if err != nil {
				// формирование ответа
				resp := RESPONSE_JSON{
					Action:       fromClient.Action,
					Requestdate:  requestTime,
					Responsedate: time.Now().Format(time.RFC3339Nano),
					Count:        intPtr(-1),
					Status:       intPtr(521),
					Message:      "Request '" + fromClient.Action + "' to " + sdl.sdl[serviceID].Dest + " is failed: " + err.Error(),
					Result:       nil,
				}

				x := loggerMSG{
					Requestdate:  requestTime,
					Responsedate: time.Now().Format(time.RFC3339Nano),
					Message:      "Request '" + fromClient.Action + "' to " + sdl.sdl[serviceID].Dest + " is failed: " + err.Error(),
					Remoteip:     remoteIP,
					Action:       fromClient.Action,
					Src:          fromClient.Fields,
					Status:       intPtr(521),
					Useragent:    r.UserAgent(),
					Ruuid:        requestUUID,
				}
				x.Meta = fromClient.Meta
				loggerChan <- x

				j, _ := json.Marshal(resp)
				log.Println("Request '" + fromClient.Action + "' to " + sdl.sdl[serviceID].Dest + " is failed: " + err.Error())
				fmt.Fprint(w, fmt.Sprintf("%s", j))
				return
			}
			x := loggerMSG{
				Requestdate:  requestTime,
				Responsedate: time.Now().Format(time.RFC3339Nano),
				Remoteip:     remoteIP,
				Action:       fromClient.Action,
				Src:          fromClient.Fields,
				Useragent:    r.UserAgent(),
				Ruuid:        requestUUID,
			}
			x.Meta = fromClient.Meta

			if *serviceResponse.Status == 200 {
				x.Message = "Request '" + fromClient.Action + "' is success: " + serviceResponse.Message
				x.Status = intPtr(200)
			} else {
				x.Message = "Request '" + fromClient.Action + "' is failed:" + serviceResponse.Message
				x.Status = serviceResponse.Status
			}
			loggerChan <- x

			serviceResponse.Requestdate = requestTime

			// Получаем список событий для пользователя
			if c_id, ok := fromClient.Fields["company_id"].(string); ok && c_id != "" {
				var ok bool
				var getEvent string

				cc := 0
				if getEvent, ok = fromClient.Fields["events"].(string); ok {
					if getEvent == "no" {
						cc--
					}
				}
				if cc == 0 {
					fields := make(map[string]interface{})
					fields["user_id"] = fromClient.Whoami
					fields["company_id"] = c_id
					fields["force"] = false
					eventsReq := apiRequest{
						Authtoken: fromClient.Authtoken,
						Ruuid:     fromClient.Ruuid,
						Whoami:    fromClient.Whoami,
						Action:    "get_events_list",
						Fields:    fields,
					}

					eventsResponse, err := crossRequest(fmt.Sprintf("%s/%s", sdl.sdl["EVENTS"].Dest, "get_events_list"), eventsReq)
					if err != nil {
						log.Println("Request 'get_events_list' is failed: " + err.Error())
					} else {
						serviceResponse.Events = eventsResponse.Result
					}
				}
			}
			serviceResponse.Responsedate = time.Now().Format(time.RFC3339Nano)
			j, _ := json.Marshal(serviceResponse)

			log.Println(remoteIP, "\t", r.Method, "\t", r.URL.Path, "\t", *serviceResponse.Status, "\t", fromClient.Action, "\t", r.UserAgent())
			fmt.Fprint(w, fmt.Sprintf("%s", j))
		} else { // backend is dead
			// формирование ответа
			resp := RESPONSE_JSON{
				Action:       fromClient.Action,
				Requestdate:  requestTime,
				Responsedate: time.Now().Format(time.RFC3339Nano),
				Count:        intPtr(-1),
				Status:       intPtr(521),
				Message:      "Internal server error: backend is dead",
				Result:       nil,
			}

			x := loggerMSG{
				Requestdate:  requestTime,
				Responsedate: time.Now().Format(time.RFC3339Nano),
				Message:      "Request '" + fromClient.Action + "' is failed: backend is dead",
				Remoteip:     remoteIP,
				Action:       fromClient.Action,
				Src:          fromClient.Fields,
				Status:       intPtr(521),
				Useragent:    r.UserAgent(),
				Ruuid:        requestUUID,
			}

			x.Meta = fromClient.Meta
			loggerChan <- x

			j, _ := json.Marshal(resp)
			log.Println(fromClient.Action, " to ", serviceID, " returns: ", "Service ", serviceID, "(", sdl.sdl[serviceID].Dest, ") is dead.")
			fmt.Fprint(w, fmt.Sprintf("%s", j))
		}
	} else {
		x := loggerMSG{
			Requestdate:  requestTime,
			Responsedate: time.Now().Format(time.RFC3339Nano),
			Message:      "Request '" + fromClient.Action + "' is failed: Method is not implemented yet",
			Remoteip:     remoteIP,
			Action:       fromClient.Action,
			Src:          fromClient.Fields,
			Status:       intPtr(501),
			Useragent:    r.UserAgent(),
			Ruuid:        requestUUID,
		}
		x.Meta = fromClient.Meta
		loggerChan <- x

		resp := RESPONSE_JSON{
			Action:       fromClient.Action,
			Requestdate:  requestTime,
			Responsedate: time.Now().Format(time.RFC3339Nano),
			Count:        intPtr(-1),
			Status:       intPtr(501),
			Message:      "Internal server error: Method is not implemented yet",
			Result:       nil,
		}
		j, _ := json.Marshal(resp)
		log.Println(remoteIP, "\t", r.Method, "\t", r.URL.Path, "\t", fromClient.Action, "\t", 501, "\t", r.UserAgent())
		fmt.Fprint(w, fmt.Sprintf("%s", j))
	}

}

func crossRequest(url string, request apiRequest) (*RESPONSE_JSON, error) {
	serviceResp := new(RESPONSE_JSON)
	var netTransport = &http.Transport{
		Dial: (&net.Dialer{
			Timeout: time.Duration(helpers.Atoi(appConfig["netdialtimeout"])) * time.Second,
		}).Dial,
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}

	var netClient = &http.Client{
		Timeout:   time.Second * time.Duration(helpers.Atoi(appConfig["netclienttimeout"])),
		Transport: netTransport,
	}

	toBackend, _ := json.Marshal(request)

	actionRequest, _ := http.NewRequest("POST", url, bytes.NewReader(toBackend))
	actionRequest.Header.Set("Content-Type", "application/json")
	actionRequest.Header.Set("Connection", "keep-alive")

	actionResult, err := netClient.Do(actionRequest)
	if actionResult != nil {
		defer actionResult.Body.Close()
	}
	if err != nil {
		return nil, err
	}
	// response validation
	err = json.NewDecoder(actionResult.Body).Decode(&serviceResp)
	if err != nil {
		return nil, err
	}

	if serviceResp.IsEmpty() {
		return nil, errors.New("Empty response from backend")
	}
	return serviceResp, nil
}
